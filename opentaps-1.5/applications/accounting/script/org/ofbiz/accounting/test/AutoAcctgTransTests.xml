<?xml version="1.0" encoding="UTF-8"?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<!-- This file has been modified by Open Source Strategies, Inc. -->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="http://ofbiz.apache.org/dtds/simple-methods.xsd">

    <!-- Test case for Accounting Transaction on Purchase -->
    <simple-method method-name="testAcctgTransOnPoReceipts" short-description="Test case for Accounting Transaction on Receipts of Purchase Order." login-required="false">
        <!-- Precondition : shipment is created from supplier and order items are issued  -->
        <!-- create a purchase order using following:
             Supplier : DemoSupplier
             Item     : WG-1111
             Quantity : 10 -->

        <!-- Post condition : Credit in account 214000 - UNINVOICED ITEM RECEIPT amount = grand total of order.
                              Debit in account 140000- INVENTORY amount = grand total of order.  -->

        <!-- set few variables so that they can be changed easily to test with different values -->
        <set field="orderId" value="DEMO10091"/>
        <set field="productId" value="GZ-2644"/>
        <set field="orderItemSeqId" value="00001"/>
        <set field="shipmentId" value="9999"/>

        <entity-one entity-name="UserLogin" value-field="userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <set field="serviceCtx.userLogin" from-field="userLogin"/>
        <set field="serviceCtx.inventoryItemTypeId" value="NON_SERIAL_INV_ITEM"/>
        <set field="serviceCtx.productId" from-field="productId"/>
        <set field="serviceCtx.facilityId" value="WebStoreWarehouse"/>
        <set field="serviceCtx.quantityAccepted" value="5" type="BigDecimal"/>
        <set field="serviceCtx.quantityRejected" value="0" type="BigDecimal"/>
        <set field="serviceCtx.shipmentId" from-field="shipmentId"/>
        <set field="serviceCtx.orderId" from-field="orderId"/>
        <set field="serviceCtx.orderItemSeqId" from-field="orderItemSeqId"/>

        <call-service service-name="receiveInventoryProduct" in-map-name="serviceCtx"/>

        <entity-and list="acctgTransList" entity-name="AcctgTrans">
            <field-map field-name="shipmentId"/>
        </entity-and>
        <first-from-list entry="acctgTrans" list="acctgTransList"/>

        <assert><if-compare field="acctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

        <get-related value-field="acctgTrans" relation-name="AcctgTransEntry" list="acctgTransEntryList"/>
        <set field="productFilter.productId" from-field="productId"/>
        <filter-list-by-and list="acctgTransEntryList" map="productFilter" to-list="acctgTransEntryList"/>

        <assert><not><if-empty field="acctgTransEntryList"/></not></assert>

        <call-simple-method method-name="UtilCheckEntriesBalance"/>

        <iterate list="acctgTransEntryList" entry="acctgTransEntry">
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                <assert>
                    <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="UNINVOICED_SHIP_RCPT"/>
                    <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="214000"/>
                </assert>
            <else>
                <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                    <assert>
                        <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="INVENTORY_ACCOUNT"/>
                        <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="140000"/>
                    </assert>
                </if-compare>
            </else>
            </if-compare>
        </iterate>
        <check-errors/>
    </simple-method>

    <simple-method method-name="testAcctgTransOnEditPoInvoice" short-description="Test case for Purchase Invoices: editing, adding taxes and shipping charges and posting to GL" login-required="false">
        <!-- Precondition: To the Purchase Invoice created add taxes and two different shipping charges
            1. for taxes: set "Invoice Item Type" = "Invoice Sales Tax" and "Unit Price" = 10$
            2. for the first shipping charge: set "Invoice Item Type" = "Invoice Shipping And Handling" and "Unit Price" = 5$
            3. for the second shipping charge: set "Invoice Item Type" = "Invoice Shipping And Handling", set "Override Gl Account Id" = "516100" and "Unit Price" = 5$
        -->
        <!-- Post condition: When status is set to ready, an accounting transaction is automatically posted to the GL:
            * Credit; in account 210000 - "ACCOUNTS PAYABLE"; amount: 290$
            * Debit; in account 214000 - "UNINVOICED ITEM RECEIPTS"; amount: 270$
            * Debit; in account 516100 - "PURCHASE ORDER ADJUSTMENTS"; amount: 10$
            * Debit; in account 510000 - "FREIGHT IN"; amount: 5$
            * Debit; in account 516100 - "PURCHASE ORDER ADJUSTMENTS"; amount: 5$
        -->

        <set field="orderId" value="DEMO10091"/>
        <entity-and list="orderItemBillings" entity-name="OrderItemBilling">
            <field-map field-name="orderId"/>
        </entity-and>
        <first-from-list entry="orderItemBilling" list="orderItemBillings"/>
        <entity-one entity-name="UserLogin" value-field="userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <set field="serviceCtx.userLogin" from-field="userLogin"/>
        <set field="serviceCtx.statusId" value="INVOICE_READY"/>
        <set field="serviceCtx.invoiceId" from-field="orderItemBilling.invoiceId"/>
        <call-service service-name="setInvoiceStatus" in-map-name="serviceCtx"/>
        <entity-one entity-name="Invoice" value-field="invoice">
            <field-map field-name="invoiceId" from-field="orderItemBilling.invoiceId"/>
        </entity-one>
        <get-related value-field="invoice" relation-name="AcctgTrans" list="acctgTransList"/>
        <first-from-list list="acctgTransList" entry="acctgTrans"/>

        <assert><if-compare field="acctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

        <get-related value-field="acctgTrans" relation-name="AcctgTransEntry" list="acctgTransEntryList"/>

        <assert><not><if-empty field="acctgTransEntryList"/></not></assert>

        <call-simple-method method-name="UtilCheckEntriesBalance"/>

        <iterate list="acctgTransEntryList" entry="acctgTransEntry">
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                <assert>
                    <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="ACCOUNTS_PAYABLE"/>
                    <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="210000"/>
                </assert>
            </if-compare>
        </iterate>
        <check-errors/>
    </simple-method>

    <simple-method method-name="testAcctgTransOnPaymentSentToSupplier" short-description="Test case for Payment sent to supplier for purchase invoice." login-required="false">
        <!--
            Precondition: New payment is created for: supplierId = "DemoSupplier", "Payment Type ID" = "Vendor Payment" and
                          a proper "Payment Method Type" (e.g. "Electronic Funds Transfer"), amount = $290

            Post condition: On payment's status is sent: a double-entry accounting transaction is automatically posted to the GL:
                * Credit; in account 111100 - "GENERAL CHECKING ACCOUNT"; amount: 290$; however this depends on the "Payment method type" selected;
                * Debit; in account 216000 - "ACCOUNTS PAYABLE - UNAPPLIED PAYMENTS"; amount: 290$
         -->

        <set field="paymentId" value="9000"/>
        <entity-one entity-name="UserLogin" value-field="userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <set field="serviceCtx.userLogin" from-field="userLogin"/>
        <set field="serviceCtx.paymentId" from-field="paymentId"/>
        <set field="serviceCtx.statusId" value="PMNT_SENT"/>

        <call-service service-name="setPaymentStatus" in-map-name="serviceCtx"/>
        <entity-one entity-name="Payment" value-field="payment">
            <field-map field-name="paymentId" from-field="paymentId"/>
        </entity-one>
        <get-related value-field="payment" relation-name="AcctgTrans" list="acctgTransList"/>
        <first-from-list list="acctgTransList" entry="acctgTrans"/>

        <assert><if-compare field="acctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

        <get-related value-field="acctgTrans" relation-name="AcctgTransEntry" list="acctgTransEntryList"/>

        <assert><not><if-empty field="acctgTransEntryList"/></not></assert>

        <call-simple-method method-name="UtilCheckEntriesBalance"/>

        <iterate list="acctgTransEntryList" entry="acctgTransEntry">
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                <assert>
                    <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="111100"/>
                </assert>
            <else>
                <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                    <assert>
                        <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="ACCPAYABLE_UNAPPLIED"/>
                        <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="216000"/>
                    </assert>
                </if-compare>
            </else>
            </if-compare>
        </iterate>
        <check-errors/>
    </simple-method>

    <!-- Test case for Accounting Transaction on Sales -->
    <simple-method method-name="testAcctgTransForSalesOrderShipments" short-description="Creation and Shipments of sales order" login-required="false">
        <!-- Precondition :
             1. create a sales order
             2. from the order view screen, approve the order
             3. from the order view screen, create a shipment to the customer (click on "New Shipment For Ship Group" and then click on the "Update" button in the next screen)
        -->
        <!-- Following process is tested by test case:
             1. issue (assign) the order items to the shipment: select the "Order Items" tab and then click on "Issue All"; this action will generate and post to the GL the accounting transaction for the items taken from the warehouse and ready to be shipped
        -->
        <!-- Post condition: all order items will be issued and it will generate and post to the GL the accounting transaction for the items taken from the warehouse and ready to be shipped
              * Credit; in account:140000 - Account Type:"INVENTORY_ACCOUNT"
              * Debit; in account:500000 - Account Type:"COGS_ACCOUNT"
        -->

        <set field="shipmentId" value="9998"/>
        <set field="orderId" value="DEMO10090"/>
        <set field="shipGroupSeqId" value="00001"/>
        <set field="orderItemSeqId" value="00001"/>
        <set field="inventoryItemId" value="9001"/>
        <set field="quantity" value="2" type="BigDecimal"/>
        <set field="productId" value="GZ-2644"/>

        <entity-one entity-name="UserLogin" value-field="userLogin" auto-field-map="false">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <set field="serviceCtx.userLogin" from-field="userLogin"/>
        <set field="serviceCtx.shipmentId" from-field="shipmentId"/>
        <set field="serviceCtx.orderId" from-field="orderId"/>
        <set field="serviceCtx.shipGroupSeqId" from-field="shipGroupSeqId"/>
        <set field="serviceCtx.orderItemSeqId" from-field="orderItemSeqId"/>
        <set field="serviceCtx.inventoryItemId" from-field="inventoryItemId"/>
        <set field="serviceCtx.quantity" from-field="quantity"/>
        <call-service service-name="issueOrderItemShipGrpInvResToShipment" in-map-name="serviceCtx"/>

        <entity-condition list="acctgTransList" entity-name="AcctgTrans">
            <condition-expr field-name="shipmentId" from-field="shipmentId"/>
            <order-by field-name="-postedDate"/>
        </entity-condition>
        <first-from-list entry="acctgTrans" list="acctgTransList"/>

        <assert><if-compare field="acctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

        <get-related list="acctgTransEntryList" relation-name="AcctgTransEntry" value-field="acctgTrans"/>

        <assert><not><if-empty field="acctgTransEntryList"/></not></assert>

        <call-simple-method method-name="UtilCheckEntriesBalance"/>

        <iterate list="acctgTransEntryList" entry="acctgTransEntry">
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                <assert>
                    <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="INVENTORY_ACCOUNT"/>
                    <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="140000"/>
                </assert>
            <else>
                <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                    <assert>
                        <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="COGS_ACCOUNT"/>
                        <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="500000"/>
                    </assert>
                </if-compare>
            </else>
            </if-compare>
        </iterate>
        <check-errors/>
    </simple-method>

    <simple-method method-name="testAcctgTransOnSalesInvoice" short-description="Test case for Accounting Transaction for sales invoice" login-required="false">
        <!-- Precondition:
            1. Create a sales order
            2. From the order view screen, approve the order
            3. From the order view screen, create a shipment to the customer (click on "New Shipment For Ship Group" and then click on the "Update" button in the next screen)
            4. Issue the order items to the shipment: select the "Order Items" tab and then click on "Issue All."
            5. From the shipment detail screen of the shipment created in the previous step (there is a link to it from the order detail screen), set the status of the shipment to "pack"(Click on "Edit" and then from statusId drop down select statusId = "Pack" and then click update); this action will generate a sales invoice
        -->
        <!-- Following process is tested by test case:
             1. Go to the invoice detail screen (there is a link to the invoice from the order detail screen) and click on the "set status to ready"; this action will generate and post to the GL the accounting transaction for the sales invoice
        -->
        <!-- Post condition: "Set status to ready"; This action will generate and post to the GL the accounting transaction for the sales invoice
              * Credit; in account=400000 - Account Type="SALES_ACCOUNT"
              * Debit; in  account=120000 - Account Type="ACCOUNTS_RECEIVABLE"
        -->
        <!-- Note: The above notes seem to assume that you are going to manually follow the preconditions above before running this test.
                   Instead the test will now use order DEMO10090 which currently preconditions 1-4 fulfilled, and we'll then update the
                   shipment to the packed status (precondition 4).  Additionally it doesn't seem to be necessary to set the invoice status
                   to ready because the invoice is created in that state.
        -->

        <entity-one entity-name="UserLogin" value-field="userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>

        <set field="serviceCtx.userLogin"  from-field="userLogin"/>
        <set field="serviceCtx.shipmentId" value="9998"/>
        <set field="serviceCtx.statusId" value="SHIPMENT_PACKED"/>
        <call-service service-name="updateShipment" in-map-name="serviceCtx"/>

        <entity-condition list="shipmentItemBillings" entity-name="ShipmentItemBilling">
            <condition-expr field-name="shipmentId" value="9998"/>
            <order-by field-name="-createdStamp"/>
        </entity-condition>
        <first-from-list entry="shipmentItemBilling" list="shipmentItemBillings"/>
        <set field="invoiceId" from-field="shipmentItemBilling.invoiceId"/>

        <entity-one entity-name="Invoice" value-field="invoice">
            <field-map field-name="invoiceId" from-field="invoiceId"/>
        </entity-one>
        <get-related value-field="invoice" relation-name="AcctgTrans" list="acctgTransList"/>

        <!-- Check the invoice transaction -->
        <set field="acctgTransFilter.acctgTransTypeId" value="SALES_INVOICE"/>
        <filter-list-by-and to-list="salesAcctgTransList" list="acctgTransList" map="acctgTransFilter"/>
        <first-from-list entry="salesAcctgTrans" list="salesAcctgTransList"/>

        <assert><if-compare field="salesAcctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

        <get-related value-field="salesAcctgTrans" relation-name="AcctgTransEntry" list="acctgTransEntryList"/>

        <assert><not><if-empty field="acctgTransEntryList"/></not></assert>

        <call-simple-method method-name="UtilCheckEntriesBalance"/>

        <set field="acctgTransEntryFilter.glAccountTypeId" value="ACCOUNTS_RECEIVABLE"/>
        <set field="acctgTransEntryFilter.glAccountId" value="120000"/>
        <filter-list-by-and list="acctgTransEntryList" to-list="accountsReceivableEntries" map="acctgTransEntryFilter"/>
        <assert><not><if-empty field="accountsReceivableEntries"></if-empty></not></assert>

        <clear-field field="acctgTransEntryFilter"/>
        <set field="acctgTransEntryFilter.glAccountId" value="400000"/>
        <filter-list-by-and list="acctgTransEntryList" to-list="salesAccountEntries" map="acctgTransEntryFilter"/>
        <assert><not><if-empty field="salesAccountEntries"></if-empty></not></assert>

        <!-- Check the payment transaction -->
        <clear-field field="acctgTransEntryFilter"/>
        <set field="acctgTransFilter.acctgTransTypeId" value="PAYMENT_APPL"/>
        <filter-list-by-and to-list="paymentAcctgTransList" list="acctgTransList" map="acctgTransFilter"/>
        <first-from-list entry="paymentAcctgTrans" list="paymentAcctgTransList"/>

        <assert><if-compare field="paymentAcctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

        <get-related value-field="paymentAcctgTrans" relation-name="AcctgTransEntry" list="acctgTransEntryList"/>

        <assert><not><if-empty field="acctgTransEntryList"/></not></assert>

        <call-simple-method method-name="UtilCheckEntriesBalance"/>

        <set field="acctgTransEntryFilter.glAccountTypeId" value="ACCOUNTS_RECEIVABLE"/>
        <set field="acctgTransEntryFilter.glAccountId" value="120000"/>
        <filter-list-by-and list="acctgTransEntryList" to-list="accountsReceivableEntries" map="acctgTransEntryFilter"/>
        <assert><not><if-empty field="accountsReceivableEntries"></if-empty></not></assert>

        <check-errors/>
    </simple-method>

    <simple-method method-name="testAcctgTransOnPaymentReceivedFromCustomer" short-description="Test case on Payment Received from customer for Sales Invoice" login-required="false">
        <!-- Precondition :-
            1. Click on the Payment top menu in the Accounting application, then click on the "Create New Payment" link.
            2. In the "New incoming payment" box, set the customer id in the "From Party ID" field; then set "Payment Type ID" = "Customer Payment" and a proper "Payment Method Type" (e.g. "Electronic Funds Transfer"); then set the "amount" and submit the form
        -->
        <!-- Following process is tested by test case:
             1. From the payment detail screen, when you are ready to post the payment to the GL, click on the "Status to Received" link
        -->
        <!-- Post condition: "Status to Received", Received Payments. When you are ready to post the payment to the GL this action will generate and post to the GL the accounting transaction for the items taken from the warehouse and ready to be shipped:
              * Credit; in glAccountId=126000 - glAccountTypeId="ACCOUNTS_RECEIVABLE - UNAPPLIED PAYMENTS"
              * Debit; in glAccountId=112000 - glAccountTypeId="UNDEPOSITED_RECEIPTS"
        -->

        <!-- Creating a payment from scratch rather than using the demo data -->

        <entity-one entity-name="UserLogin" value-field="userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <set field="serviceCtx.userLogin" from-field="userLogin"/>

        <!-- Find a customer -->
        <entity-and list="customerRoles" entity-name="PartyRole">
            <field-map field-name="roleTypeId" value="CUSTOMER"/>
        </entity-and>
        <first-from-list entry="customerRole" list="customerRoles"/>
        <set field="serviceCtx.partyIdFrom" from-field="customerRole.partyId"/>
        <set field="serviceCtx.amount" value="100.00" type="BigDecimal"/>
        <set field="serviceCtx.partyIdTo" value="Company"/>
        <set field="serviceCtx.paymentMethodTypeId" value="EFT_ACCOUNT"/>
        <set field="serviceCtx.paymentTypeId" value="CUSTOMER_PAYMENT"/>
        <set field="serviceCtx.paymentId" from-field="paymentId"/>
        <set field="serviceCtx.statusId" value="PMNT_RECEIVED"/>
        <call-service service-name="createPayment" in-map-name="serviceCtx">
            <result-to-field result-name="paymentId"/>
        </call-service>

        <entity-and list="acctgTransList" entity-name="AcctgTrans">
            <field-map field-name="paymentId"/>
            <field-map field-name="acctgTransTypeId" value="INCOMING_PAYMENT"/>
        </entity-and>
        <first-from-list list="acctgTransList" entry="acctgTrans"/>

        <assert><if-compare field="paymentAcctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

        <get-related value-field="acctgTrans" relation-name="AcctgTransEntry" list="acctgTransEntryList"/>

        <assert><not><if-empty field="acctgTransEntryList"/></not></assert>

        <call-simple-method method-name="UtilCheckEntriesBalance"/>

        <iterate entry="acctgTransEntry" list="acctgTransEntryList">
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
               <assert>
                    <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="ACCREC_UNAPPLIED"/>
                    <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="126000"/>
                </assert>
            </if-compare>
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                <assert>
                    <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="111100"/>
                </assert>
            </if-compare>
        </iterate>
        <check-errors/>
    </simple-method>

    <!-- Test case for Accounting Transaction on Manufacturing -->
    <simple-method  method-name="testCalculateProductCosts" short-description="Product cost test case on estimated standard costs calculation" login-required="false">
        <set field="serviceCtx.productId" value="PROD_MANUF"/>
        <set field="serviceCtx.currencyUomId" value="USD"/>
        <set field="serviceCtx.costComponentTypePrefix" value="EST_STD"/>
        <entity-one entity-name="UserLogin" value-field="serviceCtx.userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <call-service service-name="calculateProductCosts" in-map-name="serviceCtx">
            <result-to-field result-name="totalCost"/>
        </call-service>
        <assert>
            <if-compare field="totalCost" operator="equals" value="84.00" type="BigDecimal"/>
        </assert>
        <check-errors/>
    </simple-method>

    <simple-method method-name="testAcctgTransOnMaterialIssuance" short-description="Production run test case for material issuance from the warehouse" login-required="false">
        <!-- Precondition: Inventory is received for following products:
                 productId = MAT_A_COST, quantity = 4, facilityId = Web Store Warehouse
                 productId = MAT_B_COST, quantity = 6, facilityId = Web Store Warehouse
             then new production run is created and then started for following product
                 productId = PROD_MANUF, quantity = 2, facilityId = Web Store Warehouse

            Post condition:- In entity "AcctgTransEntry" at least two entries will be created for MAT_A_COST
                 * Credit; in account 141000 - "RAW MATERIALS INVENTORY"; amount: 36$
                 * Debit; in account 142000 - "WORK IN PROGRESS INVENTORY"; amount: 36$
            similarly for product MAT_B_COST
                 * Credit; in account 141000 - "RAW MATERIALS INVENTORY"; amount: 42$
                 * Debit; in account 142000 - "WORK IN PROGRESS INVENTORY"; amount: 42$ -->

        <!-- Create a production run, TODO: move this to test data so we only have to do the issuance -->
        <entity-one entity-name="UserLogin" value-field="userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <set field="serviceCtx.userLogin" from-field="userLogin"/>
        <set field="serviceCtx.facilityId" value="WebStoreWarehouse"/>
        <set field="serviceCtx.pRQuantity" value="2" type="BigDecimal"/>
        <set field="serviceCtx.productId" value="PROD_MANUF"/>
        <set field="serviceCtx.startDate" value="${date:nowTimestamp()}" type="Timestamp"/>
        <set field="serviceCtx.workEffortName" value="ACCTG_TEST_PROD_RUN"/>
        <call-service service-name="createProductionRun" in-map-name="serviceCtx">
            <result-to-field result-name="productionRunId"/>
        </call-service>

        <clear-field field="serviceCtx"/>
        <set field="serviceCtx.userLogin" from-field="userLogin"/>
        <set field="serviceCtx.productionRunId" from-field="productionRunId"/>
        <set field="serviceCtx.statusId" value="PRUN_DOC_PRINTED"/>
        <call-service service-name="changeProductionRunStatus" in-map-name="serviceCtx"/>

        <entity-and list="prodTasks" entity-name="WorkEffort">
            <field-map field-name="workEffortParentId" from-field="productionRunId"/>
        </entity-and>
        <first-from-list entry="taskWorkEffort" list="prodTasks"/>
        <set field="workEffortId" from-field="taskWorkEffort.workEffortId"/>
        <clear-field field="serviceCtx"/>
        <set field="serviceCtx.workEffortId" from-field="workEffortId"/>
        <entity-one entity-name="UserLogin" value-field="serviceCtx.userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <call-service service-name="issueProductionRunTask" in-map-name="serviceCtx"/>

        <entity-condition entity-name="WorkEffortAndInventoryAssign" list="workEffortAndInventoryAssigns">
            <condition-expr field-name="workEffortId" operator="equals" from-field="workEffortId"/>
        </entity-condition>

        <assert><not><if-empty field="workEffortAndInventoryAssigns"/></not></assert>

        <set field="totalIssuedQty_MAT_A_COST" value="0.0" type="BigDecimal"/>
        <set field="totalIssuedQty_MAT_B_COST" value="0.0" type="BigDecimal"/>
        <iterate list="workEffortAndInventoryAssigns" entry="workEffortAndInventoryAssign">
            <if-compare field="workEffortAndInventoryAssign.productId" operator="equals" value="MAT_A_COST">
                <calculate field="totalIssuedQty_MAT_A_COST">
                    <calcop operator="add">
                        <calcop operator="get" field="workEffortAndInventoryAssign.quantity"/>
                        <calcop operator="get" field="totalIssuedQty_MAT_A_COST"/>
                    </calcop>
                </calculate>
            <else>
                <if-compare field="workEffortAndInventoryAssign.productId" operator="equals" value="MAT_B_COST">
                    <calculate field="totalIssuedQty_MAT_B_COST">
                        <calcop operator="add">
                            <calcop operator="get" field="workEffortAndInventoryAssign.quantity"/>
                            <calcop operator="get" field="totalIssuedQty_MAT_B_COST"/>
                        </calcop>
                    </calculate>
                </if-compare>
            </else>
            </if-compare>
        </iterate>
        <assert>
            <if-compare field="totalIssuedQty_MAT_A_COST" operator="equals" value="4.0" type="BigDecimal"/>
            <if-compare field="totalIssuedQty_MAT_B_COST" operator="equals" value="6.0" type="BigDecimal"/>
        </assert>
        <entity-condition entity-name="AcctgTrans" list="acctgTransList">
            <condition-list combine="and">
                <condition-expr field-name="acctgTransTypeId" operator="equals" value="INVENTORY"/>
                <condition-expr field-name="workEffortId" operator="equals" from-field="workEffortId"/>
            </condition-list>
        </entity-condition>
        <assert><not><if-empty field="acctgTransList"/></not></assert>

        <iterate list="acctgTransList" entry="acctgTrans">
            <assert><if-compare field="acctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

            <get-related list="acctgTransEntryList" relation-name="AcctgTransEntry" value-field="acctgTrans"/>
            <assert><not><if-empty field="acctgTransEntryList"/></not></assert>
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                    <assert>
                        <or>
                            <if-compare field="acctgTransEntry.productId" operator="equals" value="MAT_A_COST"/>
                            <if-compare field="acctgTransEntry.productId" operator="equals" value="MAT_B_COST"/>
                        </or>
                        <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="RAWMAT_INVENTORY"/>
                        <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="141000"/>
                    </assert>
                <else>
                    <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                        <assert>
                            <if-compare field="acctgTransEntry.productId" operator="equals" value="PROD_MANUF"/>
                            <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="WIP_INVENTORY"/>
                            <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="142000"/>
                        </assert>
                    </if-compare>
                </else>
                </if-compare>
            </iterate>
        </iterate>
        <check-errors/>
    </simple-method>

    <simple-method method-name="testAcctgTransForActualManufacturingCost" short-description="Production run test case for actual manufacturing costs" login-required="false">
        <!-- Precondition: Inventory is received for the following products:
                (1) productId = MAT_A_COST, quantity = 4, facilityId = Web Store Warehouse
                (2) productId = MAT_B_COST, quantity = 6, facilityId = Web Store Warehouse
             then new production run is created, issued components for following product
                (1) productId = PROD_MANUF,  quantity = 2, facilityId = Web Store Warehouse
             Post condition: In entity "AcctgTransEntry" two entries will be created:
                    * Credit: in account 600000 - "EXPENSE"; amount: 250$
                    * Debit: in account 142000 - "WORK IN PROGRESS INVENTORY", amount: 250$  -->

        <!-- Find the production run created in the last test -->
        <entity-and list="productionRuns" entity-name="WorkEffort">
            <field-map field-name="workEffortName" value="ACCTG_TEST_PROD_RUN"/>
            <field-map field-name="workEffortTypeId" value="PROD_ORDER_HEADER"/>
            <field-map field-name="workEffortPurposeTypeId" value="WEPT_PRODUCTION_RUN"/>
        </entity-and>
        <first-from-list entry="productionRun" list="productionRuns"/>
        <set field="productionRunId" from-field="productionRun.workEffortId"/>

        <entity-and list="prodTasks" entity-name="WorkEffort">
            <field-map field-name="workEffortParentId" from-field="productionRunId"/>
        </entity-and>
        <first-from-list entry="taskWorkEffort" list="prodTasks"/>
        <set field="workEffortId" from-field="taskWorkEffort.workEffortId"/>

        <set field="serviceCtx.productionRunId" from-field="productionRunId"/>
        <set field="serviceCtx.workEffortId" from-field="workEffortId"/>
        <set field="serviceCtx.statusId" value="PRUN_RUNNING"/>
        <entity-one entity-name="UserLogin" value-field="serviceCtx.userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <call-service service-name="changeProductionRunTaskStatus" in-map-name="serviceCtx"/>
        <set field="serviceCtx.statusId" value="PRUN_COMPLETED"/>
        <call-service service-name="changeProductionRunTaskStatus" in-map-name="serviceCtx"/>

        <entity-condition entity-name="AcctgTrans" list="acctgTransList">
            <condition-list combine="and">
                <condition-expr field-name="workEffortId" operator="equals" from-field="workEffortId"/>
                <condition-expr field-name="acctgTransTypeId" operator="equals" value="MANUFACTURING"/>
            </condition-list>
        </entity-condition>
        <assert><not><if-empty field="acctgTransList"></if-empty></not></assert>
        <iterate list="acctgTransList" entry="acctgTrans">
            <assert><if-compare field="acctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

            <get-related value-field="acctgTrans" relation-name="AcctgTransEntry" list="acctgTransEntryList"/>
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                    <assert>
                        <if-compare field="acctgTransEntry.productId" operator="equals" value="PROD_MANUF"/>
                        <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="OPERATING_EXPENSE"/>
                        <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="600000"/>
                    </assert>
                <else>
                    <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                        <assert>
                            <if-compare field="acctgTransEntry.productId" operator="equals" value="PROD_MANUF"/>
                            <if-compare field="acctgTransEntry.glAccountTypeId" operator="equals" value="WIP_INVENTORY"/>
                            <if-compare field="acctgTransEntry.glAccountId" operator="equals" value="142000"/>
                        </assert>
                    </if-compare>
                </else>
                </if-compare>
            </iterate>
        </iterate>
        <check-errors/>
    </simple-method>

    <simple-method  method-name="testAcctgTransOnAddFinishedProductsIntoWarehouse" short-description="Production run test case on add finished product into warehouse" login-required="false">
        <!-- Precondition: Inventory is received for following products:
                 productId = MAT_A_COST, quantity = 4, facilityId = Web Store Warehouse
                 productId = MAT_B_COST, quantity = 6, facilityId = Web Store Warehouse
             then new production run is created and started for following product:
                 productId = PROD_MANUF, quantity = 2, facilityId = Web Store Warehouse
             then issue components and complete the product issuance and at last put 2 quantities into "Stock in" field
             Post condition: In entity "AcctgTransEntry" two entries will be created:
                * Debit, in account 140000 - "INVENTORY"; amount: 168.00$
                * Credit, in account 142000 - "WORK IN PROGRESS INVENTORY", amount: 168.00$ -->

        <entity-and list="productionRuns" entity-name="WorkEffort">
            <field-map field-name="workEffortName" value="ACCTG_TEST_PROD_RUN"/>
            <field-map field-name="workEffortTypeId" value="PROD_ORDER_HEADER"/>
            <field-map field-name="workEffortPurposeTypeId" value="WEPT_PRODUCTION_RUN"/>
        </entity-and>
        <first-from-list entry="productionRun" list="productionRuns"/>

        <set field="serviceCtx.workEffortId" from-field="productionRun.workEffortId"/>
        <set field="serviceCtx.workEffortId" from-field="workEffortId"/>
        <entity-one entity-name="UserLogin" value-field="serviceCtx.userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <call-service service-name="productionRunProduce" in-map-name="serviceCtx"/>

        <!-- For credit entry -->
        <entity-and entity-name="AcctgTransEntry" list="acctgTransEntryList">
            <field-map field-name="productId" value="PROD_MANUF"/>
            <field-map field-name="glAccountTypeId" value="WIP_INVENTORY"/>
            <field-map field-name="glAccountId" value="142000"/>
            <order-by field-name="-createdStamp"/>
        </entity-and>
        <first-from-list list="acctgTransEntryList" entry="acctgTransEntry"/>
        <assert>
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C"/>
            <if-compare field="acctgTransEntry.origAmount" operator="equals" value="168.00" type="BigDecimal"/>
        </assert>

        <!-- Check the AcctgTrans itself -->
        <get-related-one to-value-field="acctgTrans" relation-name="AcctgTrans" value-field="acctgTransEntry"/>
        <assert><if-compare field="acctgTrans.glJournalId" operator="not-equals" value="ERROR_JOURNAL"/></assert>

        <!-- For debit entry -->
        <entity-and entity-name="AcctgTransEntry" list="acctgTransEntryList">
            <field-map field-name="productId" value="PROD_MANUF"/>
            <field-map field-name="glAccountTypeId" value="INVENTORY_ACCOUNT"/>
            <field-map field-name="glAccountId" value="140000"/>
            <order-by field-name="-createdStamp"/>
        </entity-and>
        <first-from-list list="acctgTransEntryList" entry="acctgTransEntry"/>
        <assert>
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="D"/>
            <if-compare field="acctgTransEntry.origAmount" operator="equals" value="168.00" type="BigDecimal"/>
        </assert>
        <check-errors/>
    </simple-method>

    <simple-method method-name="UtilCheckEntriesBalance" login-required="false"
            short-description="Short util method that takes a list of AcctgTransEntry values (acctgTransEntryList) and checks that the debit and credit totals balance.">
        <set field="debitTotal" type="BigDecimal" value="0.0"/>
        <set field="creditTotal" type="BigDecimal" value="0.0"/>

        <assert><not><if-empty field="acctgTransEntryList"/></not></assert>
        <iterate list="acctgTransEntryList" entry="acctgTransEntry">
            <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                <calculate field="creditTotal">
                    <calcop operator="get" field="creditTotal"/>
                    <calcop operator="add" field="acctgTransEntry.origAmount"/>
                </calculate>
            <else>
                <if-compare field="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                    <calculate field="debitTotal">
                        <calcop operator="get" field="debitTotal"/>
                        <calcop operator="add" field="acctgTransEntry.origAmount"/>
                    </calculate>
                </if-compare>
            </else>
            </if-compare>
        </iterate>
        <assert>
            <if-compare-field field="debitTotal" operator="equals" to-field="creditTotal" type="BigDecimal"/>
        </assert>
    </simple-method>

</simple-methods>
